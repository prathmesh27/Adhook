<!DOCTYPE html>
<html>
    <head>
        <title>ADHOOK</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <!-- Chrome, Firefox OS and Opera -->
        <meta name="theme-color" content="#054166">
        <!-- Windows Phone -->
        <meta name="msapplication-navbutton-color" content="#054166">
        <!-- iOS Safari -->
        <meta name="apple-mobile-web-app-status-bar-style" content="#054166">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
        <!-- Bootstrap CSS -->
        <link rel="stylesheet" href="css/slick.css">
        <link rel="stylesheet" href="css/slick-theme.css">
        <link rel="stylesheet" href="css/bootstrap.css">
         <link rel="stylesheet" href="css/style.css">
        <link rel="stylesheet" href="css/responsive.css">
        <style type="text/css">
            @font-face {
              font-family: 'PoetsenOne-Regular';
              src: url('fonts/PoetsenOne-Regular.ttf') format('truetype');
            }
            .meme-template{
                position: relative;
                width: 1000px;
            }
            .top-input{
                position: absolute;
                top: 10px;
                width: 100%;
            }
             .bottom-input{
                position: absolute;
                bottom: 10px;
                width: 100%;
            }
            #img{
                width:100% ;
            }
            .form-control{
                background:transparent;
                border:none;
                font-size: 30px;font-family: 'PoetsenOne-Regular';
            }
            #container{
                width: 1000px;
            }
        </style>
    </head>
    <main>
        <section>
            <div class="meme-template"  id='container'>
                <img src="https://dummyimage.com/900x600/eeeeee/000000" id="img">
                <div class="top-input" id='slider'>
                    <textarea type="text" name="" id="" placeholder="Top text goes here" class="top form-control">
                    </textarea>
                </div>
                <div class="bottom-input">
                     <textarea type="text" name="" id="" placeholder="Bottom text goes here" class="bottom form-control">
                     </textarea>
                </div>
            </div>
        </section>
    </main>
    <footer>
             <script src="js/jquery-3.4.1.min.js"></script>
            <script src="js/popper.min.js"></script>
            <script src="js/bootstrap.min.js"></script>
            <script src="js/slick.min.js"></script>
            <!-- Example autosize.js CDN Reference -->
                <script src='https://cdnjs.cloudflare.com/ajax/libs/autosize.js/3.0.15/autosize.min.js'></script>
                <script>
                    // Automatically size all of your <textarea> elements as you type
                    autosize(document.querySelectorAll('textarea'));
                </script>
        </footer>
        <script type="text/javascript">       
        /*
This is a pure javascript driven drag dragger that does not require handlers to be added and/or removed or changed from elements whenever the slider is moved. The cost is that the document.onmousemove event is always being tested.

Note: not too worried about variable scope or JSLint adherance in this snippet.
 -Dave
 */

//before we even start fix the annoying select-cursor bug in Chrome:
document.onselectstart = function(e) {
  e.preventDefault();
  return false;
}

//create handles for elements that were instantiated in the HTML markup:
var slider = document.getElementById('slider'),
  container = document.getElementById('container');

//define some initial states variables, append to their elements:
document.mouseState = 'up';
slider.mouseState = 'up';
slider.lastMousePosY = null;
slider.lastMousePosX = null;
slider.proposedNewPosY = parseInt(slider.style.top, 10); //converts '10px' to 10
slider.proposedNewPosX = parseInt(slider.style.left, 10);

//We will need to access the top and height properties of the slider and track.
//Set them here initally rather than in CSS so that we can access them without getComputedStyle calls:
slider.style.top = '40px';
slider.style.left = '40px';
slider.style.height = '60px';
// slider.style.width = '60px';
container.style.top = '20px';
container.style.left = '20px';
// container.style.height = '200px';
// container.style.width = '400px';

//Rather than having the mousedown and mouseup events add or remove handlers,
//we have the events set states. There are two functions for document events, and
//two for every slider (blue box) in the document. Below we have 4 functions and they
//are never removed or re-assigned:

//Document mouse event functions:
document.onmousedown = function() {
  document.mouseState = 'down';
};

document.onmouseup = function() {
  document.mouseState = 'up';
  slider.mouseState = 'up';
};

//Slider mouse event functions:
slider.onmousedown = function(e) {
  slider.lastMousePosY = e.pageY; //<-this is so that if you lift the mouse, move it and grab the slider again, it will not jump.
  slider.lastMousePosX = e.pageX;
  slider.mouseState = 'down';
  document.mouseState = 'down';
};

slider.onmouseup = function(e) {
  slider.mouseState = 'up';
  document.mouseState = 'up';
};

//Helper function. Not strictly required, but will make the logic down the bottom
//easier to follow by simplifying nested parens
var getAtInt = function getAtInt(obj, attrib) {
  return parseInt(obj.style[attrib], 10);
};


  //Below is the Drag-logic function. Any mouse movement on the document fires this handler.

  //The outermost if-statement checks to see if this (or potentially any other) div
  //is being dragged. This is done by examining the state variables as set
  //above.

  //The inner if-comparisons check to make sure we only
  //dragging the slider within the bounds of the container. If so, 
  //then set the slider to the newly proposed coordinates. This is
  //done by adding the X and Y deltas of the cursor location from the previous
  //loop through here. Then storing the current mouse coordinates for next time
  //here. 
document.onmousemove = function(e) {
  if ((document.mouseState === 'down') && (slider.mouseState === 'down')) {
    slider.proposedNewPosY = getAtInt(slider, 'top') + e.pageY - slider.lastMousePosY;
    slider.proposedNewPosX = getAtInt(slider, 'left') + e.pageX - slider.lastMousePosX;

    if (slider.proposedNewPosY < getAtInt(container, 'top')) {
      slider.style.top = container.style.top;
    } else if (slider.proposedNewPosY > getAtInt(container, 'top') + getAtInt(container, 'height') - getAtInt(slider, 'height')) {
      slider.style.top = getAtInt(container, 'top') + getAtInt(container, 'height') - getAtInt(slider, 'height') + 'px';
    } else {
      slider.style.top = slider.proposedNewPosY + 'px';
    }

    if (slider.proposedNewPosX < getAtInt(container, 'left')) {
      slider.style.left = container.style.left;
    } else if (slider.proposedNewPosX > getAtInt(container, 'left') + getAtInt(container, 'width') - getAtInt(slider, 'width')) {
      slider.style.left = getAtInt(container, 'left') + getAtInt(container, 'width') - getAtInt(slider, 'width') + 'px';
    } else {
      slider.style.left = slider.proposedNewPosX + 'px';
    }
    slider.lastMousePosY = e.pageY;
    slider.lastMousePosX = e.pageX;
  }

  // place other slider logic block(s) here for more sliders on the page or for some other moving element:
  //if ((document.mouseState === 'down') && (someOtherSlider.mouseState === 'down')) {   .......
};
        </script>
    </body>
    </html>